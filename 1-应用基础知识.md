应用基础知识
===

<!-- TOC -->

- [系统架构](#系统架构)
    - [「安全沙箱」](#安全沙箱)
    - [共享数据和系统服务](#共享数据和系统服务)
- [应用组件](#应用组件)
    - [四种应用组件类型](#四种应用组件类型)
        - [Activity](#activity)
        - [服务](#服务)
        - [内容提供程序](#内容提供程序)
        - [广播接收器](#广播接收器)
    - [跨应用调用组件](#跨应用调用组件)
    - [如何启动一个组件（Intent 那些事）](#如何启动一个组件intent-那些事)
- [组件清单](#组件清单)
    - [声明组件](#声明组件)
    - [声明组件功能](#声明组件功能)
    - [声明应用要求](#声明应用要求)
- [应用资源](#应用资源)

<!-- /TOC -->

## 系统架构

### 「安全沙箱」

- Android 系统是一种多用户的 Linux 系统，其中的每个 **应用** 都是一个不同的用户
- 默认的情况下，每个应用都会被分配到一个唯一的 Linux **用户 ID**，用来设置应用的文件权限
- 每个进程都有自己的虚拟机，因而应用代码被隔离在 **独立的虚拟机** 中
- 默认情况下，每个应用 **独享一个进程**，其会在需要时启用，不需要/资源不足时被关闭
- 通过上述措施，应用只能访问其运行所需的组件

### 共享数据和系统服务

- 两个应用 **共享同一用户 ID** 时可以访问彼此的文件，在具有相同的证书签署时，甚至可以共享 Linux 进程和虚拟机
- 应用可以通过 **请求权限** 来获得数据或服务的获取权限

## 应用组件

应用组件是 Android 应用的基本组成部分。每一个组件都是一个点，而系统可以透过点进入应用。当然，并非每个组建都是实际的接入点，不过每个组件都是独立存在，但可以相互依赖的实体。组件之间的差别主要是 **服务对象** 和 **生命周期**。

### 四种应用组件类型

#### Activity

是 **具有用户界面的单一屏幕**。一个应用可以存在多个 Activity，在该应用允许的情况下，其他应用可以仅启动其中一个 Activity。

其实现是 `Activity` 的子类。

#### 服务

是 **一种在后台运行的组件**。主要用于 **长时间运行的操作** 或者 **为远程进程提供支持**。服务可以在执行的同时不足段用户与任意应用中的 Activity 之间的交互，而服务也可以被其他组件启动，或是与其他组件绑定进行交互。

其实现是 `Service` 的子类。

#### 内容提供程序

是 **管理一组应用数据** 的组件。该应用或是其他应用（如果该应用允许）可以透过该组件查询和修改该应用管理的数据。这些数据可能以任意形式存储在任何地点。

其实现是 `ContentProvider` 的子类，实现时必须要一并实现一组与其他应用交互的标准 API。

笔者注：个人认为其实也算是“服务”的范畴，不过二者实现并不相同，请开发者多加留意

#### 广播接收器

是 **响应系统范围广播通知** 的组件。**广播** 可以理解为一种通知或是事件，常见的广播有*屏幕已关闭*、*电池电量不足*等。该组件没有用户界面，但是能够创建状态栏通知。这种通知可以作为通向其他组件的通道。**其被设计来执行极少量的工作**，请勿为其部署重量级的计算。

其实现是 `BroadcastReceiver`，其发送的每条广播都是一个 `Intent` 对象。

### 跨应用调用组件

在 Android 中，任何应用都可以启动其他应用的组件（有时这需要请求用户的允许）。不过由于之前所说的权限的限制，应用 **并没有权限直接调用** 其他应用的组件。因而在实际操作中，应用通过 **给系统传递信息** （包装为一个 `Intent`），然后由系统处理调用组件的具体工作。这使得代码的复用得以跨应用地实现。当某个组件被系统调用时，该应用的进程将会被启动并实例化目标组件的类。在这样的设计下，任何组件都能成为应用的接入点，因而 **安卓应用不存在单一入口** （也就是 main 函数）。

### 如何启动一个组件（Intent 那些事）

*Intent* 是系统中的信使，作为一种 **异步消息**，应用需要透过它通知系统，才能启动组件，**无论这个组件是否属于该应用**。应用可以透过 `Intent` 对象来创建 Intent。

对于 Activity 和服务来说，一个 Intent 可以指定 **启动某个特定组件** （称为显式的 Intent）或者 **具有特定功能的某类组件中的一个**（由用户挑选，称为隐式的 Intent），并 **指定** 目标组件 **需要完成的功能**在开启组件的同时，Intent 也可以向目标组件 **传递其需要的信息**，或是被目标组件派来 **提供返回的信息**。

而对于广播接收器来说，Intent 只会 **定义广播的内容**。

唯一和 Intent 沾不上边的组件是内容提供程序。这个小家伙只在成为 `ContentResolver`，也就是 **内容解析程序** 的请求目标时才启动。这个程序负责 **接受应用对信息的请求**，并且将其 **转告给内容提供程序**。

注：内容解析程序是为了分离不同的模块而存在，其帮助将数据处理层解耦为一个独立的模块。

具体的使用方法如下：

- 通过将 `Intent` 传递给 `startActivity()` 或是 `startActivityForResult()` 方法来启动一个 `Activity`，你也可以通过这种方式来给已启动的 `Activity` 安排新的任务
- 通过将 `Intent` 传递给 `startService()` 来启动服务，或是对已有的服务下达新的命令。而对于绑定服务，则使用 `bindService()` 方法
- 通过将 `Intent` 传递给 `sendBoardcast()`，`sendOrderedBoardcast()`，`sendStickyBoardcast()` 等方法来发送不同的广播
- 通过在一个 `ContentResolver` 上调用 `query()` 方法来启动对于内容提供程序的内容的查询

## 组件清单

`AndroidManifest.xml` 是安卓应用中的一个特殊文件，它用于保存 **应用中存在的所有组件**，因而它也叫做 **清单文件**。除此之外，清单文件还有很多其他作用：

- 确定应用需要的 **用户权限**
- 确定应用的 **API 级别**，以及最低要求的 API
- 声明应用需要的硬件和软件功能（即对 **运行环境** 的要求）
- 声明应用需要额外链接的 **API 库**（如 Google Map）

### 声明组件

以如下的代码为例：

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest ... >
    <application android:icon="@drawable/app_icon.png" ... >
        <activity android:name="com.example.project.ExampleActivity"
                  android:label="@string/example_label" ... >
        </activity>
        ...
    </application>
</manifest>
```

所有组件的声明需要在 `<application>` 标签内，这个标签标识了整个应用，它的属性 `android:icon` 用于声明应用的图标。

而 `<activity>` 标签声明了该应用下的一个 `Activity` 组件，在它的属性中，`android:name` 指定了 `Activity` 子类的 **完全限定类名**，`android:label` 属性指定用作 `Activity` 的 **用户可见标签** 的字符串。

特别需要注意的是，`android:name` 在应用发布后非常不建议更改，否则会破坏掉诸如应用快捷方式等的一些功能。

除了 `Activity` 外，其他组件也是通过类似的方式声明的：

- **服务** 的 `<service>`
- **广播接收器** 的 `<receiver>`
- **内容提供器** 的 `<provider>`

只有在清单文件中声明了的组件才 **对系统可见**，而只有系统才能够启动组件。所以，没有被声明的组件将 **永远不能运行**。但是 **广播接收器除外**，它还可以借由代码中的 `BroadcastReceiver` 等对象动态创建，并且通过 `registerReceiver()` 来注册到系统中。

### 声明组件功能

我们先前有提到隐式的 Intent，也就是只指定需要完成的操作，由用户选择由哪个组件来执行。那么我们怎么知道哪些组件可以完成这个操作呢？于是我们就需要在应用的清单文件中声明组件可以响应何种类型的 Intent。

示例：

```xml
<manifest ... >
    ...
    <application ... >
        <activity android:name="com.example.project.ComposeEmailActivity">
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <data android:type="*/*" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
    </application>
</manifest>
```

具体来讲，在声明一个 Activity 的时候，我们可以选择性地加入一个 Intent 过滤器，也就是 `<intent-filter>`，来告诉系统组件能够响应的 Action。在本例中，通过定义 action，该应用可以响应其他应用创建的，包含 `ACTION_SEND` 操作的 Intent。

### 声明应用要求

安卓系统能够安装在极为多样的平台上，因而 **不是每个平台都能运行您的应用**，所以我们最好在清单文件中声明应用的正常运行都需要些什么。当然，**系统并不会理会这些声明**，处理这部分兼容性任务的是类似于 Google Play 的应用平台。

例子：

```xml
<manifest ... >
    <uses-feature android:name="android.hardware.camera.any"
                  android:required="true" />
    <uses-sdk android:minSdkVersion="7" android:targetSdkVersion="19" />
    ...
</manifest>
```

上述代码告诉 Google Play：这个应用必须使用相机硬件，并且最少要求 API 7 以上的设备才可以安装。**但是你硬要装，安卓系统本身是没有办法拒绝的**（闪退警告）。顺带一提，如果 `android:required` 设置为 `false`，代表的意思是「不必要」，而不是「不需要」。

## 应用资源

Android 应用当然不会只是乏味的代码，丰富的音视频，或是其他类型的资源也是应用的重要组成。这些资源应该是 **和源代码分离的**，如此一来才能保证在不修改代码的情况下，简单地更新应用的资源。

对于任何 Android 项目中的资源，SDK 工具会为其定义一个 **唯一的整形 ID**，通过它，你就可以来引用代码，或是 XML 中定义的其他资源中的资源。例如，如果您的应用包含一个名为 `logo.png` 的图像文件（保存在 `res/drawable/` 目录中），则 SDK 工具会生成一个名为 `R.drawable.logo` 的资源 ID，您可以利用它来引用该图像并将其插入您的用户界面。

如此做的好处是，应用可以很轻松地在不同的资源集间切换，这可以是一次不修改代码的迭代，也可以是一次本地的语言的切换（字符串也可以是一种「资源」）。后者的这种切换通常是通过 **限定符** 实现的。

**限定符** 用于区分应用的不同运行环境，比如语言、排列方向等等。您应该通过为不同的限定符建立不同的资源目录，来实现不同场景下资源的快速切换。（例如法语的限定符为 `fr`，中文为 `zh`，那么语言的切换可能落实在 `/res/values-fr/` 到 `/res/values-zh/` 两个目录间）